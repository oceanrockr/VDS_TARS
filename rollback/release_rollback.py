#!/usr/bin/env python3
"""
Release Rollback System - Phase 14.7 Task 6

Production-grade rollback and recovery system for published releases.
Provides safe rollback with atomic guarantees, policy enforcement, and audit logging.

Author: T.A.R.S. Development Team
Version: 1.0.0
Date: 2025-11-28
"""

import json
import hashlib
import shutil
import uuid
import platform
from abc import ABC, abstractmethod
from pathlib import Path
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, asdict, field
from datetime import datetime, timezone
from enum import Enum
import logging


# ============================================================================
# LOGGING SETUP
# ============================================================================

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


# ============================================================================
# CUSTOM EXCEPTIONS (Exit Codes 40-49)
# ============================================================================

class RollbackError(Exception):
    """Base exception for all rollback errors."""
    exit_code = 49

    def __init__(self, message: str, exit_code: Optional[int] = None):
        super().__init__(message)
        if exit_code is not None:
            self.exit_code = exit_code


class RollbackVersionNotFoundError(RollbackError):
    """Version to rollback not found in repository."""
    exit_code = 40


class RollbackPolicyViolationError(RollbackError):
    """Rollback policy violation."""
    exit_code = 41


class RollbackDependencyError(RollbackError):
    """Rollback dependency check failed."""
    exit_code = 42


class RollbackAtomicError(RollbackError):
    """Atomic rollback operation failed."""
    exit_code = 43


class RollbackIndexError(RollbackError):
    """Index restoration failed."""
    exit_code = 44


class RollbackBackupError(RollbackError):
    """Backup operation failed."""
    exit_code = 45


class RollbackAlreadyRolledBackError(RollbackError):
    """Version already rolled back."""
    exit_code = 46


class RollbackDryRunError(RollbackError):
    """Dry-run simulation failed."""
    exit_code = 47


class RollbackManifestError(RollbackError):
    """Rollback manifest generation/loading failed."""
    exit_code = 48


# ============================================================================
# ENUMS
# ============================================================================

class RollbackPolicy(Enum):
    """Rollback policy modes."""
    STRICT = "strict"
    LENIENT = "lenient"


class RollbackStatus(Enum):
    """Rollback operation status."""
    SUCCESS = "success"
    FAILED = "failed"
    DRY_RUN = "dry_run"
    PARTIAL = "partial"


class RollbackType(Enum):
    """Type of rollback operation."""
    FULL = "full"                      # Rollback entire version
    ARTIFACTS_ONLY = "artifacts_only"  # Rollback artifacts, keep index entry
    INDEX_ONLY = "index_only"          # Remove from index, keep artifacts


# ============================================================================
# DATA CLASSES
# ============================================================================

@dataclass
class RollbackManifest:
    """
    Rollback manifest for restoration.
    Created during rollback to enable potential restoration.
    """
    version: str
    rollback_timestamp: str
    rollback_id: str
    artifacts_removed: List[str]
    index_state_before: Dict[str, Any]
    index_state_after: Dict[str, Any]
    rollback_type: str
    rollback_reason: str = ""
    can_restore: bool = True


@dataclass
class RollbackPlan:
    """
    Rollback execution plan.
    Generated by RollbackPlanner, consumed by RollbackExecutor.
    """
    version: str
    rollback_type: RollbackType
    artifacts_to_remove: List[str]
    index_entry_to_remove: Optional[Dict[str, Any]]
    previous_index_state: Optional[Dict[str, Any]]
    dependencies_satisfied: bool
    estimated_duration_seconds: float
    warnings: List[str] = field(default_factory=list)
    dry_run: bool = False


@dataclass
class RollbackReport:
    """Comprehensive rollback report."""
    version: str
    status: str
    timestamp: str
    rollback_type: str
    rollback_id: str
    repository_type: str
    repository_location: str
    policy_mode: str
    dry_run: bool = False

    # Pre-flight checks
    version_exists: bool = False
    policy_passed: bool = False
    dependencies_satisfied: bool = False

    # Rollback details
    artifacts_removed: List[str] = field(default_factory=list)
    total_artifacts_removed: int = 0
    total_bytes_freed: int = 0
    rollback_duration_seconds: float = 0.0

    # Post-rollback
    index_updated: bool = False
    backup_created: bool = False
    manifest_created: bool = False
    audit_log_created: bool = False
    audit_log_signed: bool = False

    # Issues/warnings
    warnings: List[str] = field(default_factory=list)
    errors: List[str] = field(default_factory=list)

    # Exit
    exit_code: int = 0
    summary: str = ""


# ============================================================================
# ROLLBACK REPOSITORY ADAPTER
# ============================================================================

class RollbackRepositoryAdapter:
    """
    Adapter for rollback-specific repository operations.
    Wraps AbstractRepository with rollback semantics.
    """

    def __init__(self, repository):
        """
        Initialize with publisher's AbstractRepository.

        Args:
            repository: Instance of AbstractRepository (from publisher)
        """
        self.repository = repository
        self.backup_prefix = ".rollback-backups"
        logger.info(f"RollbackRepositoryAdapter initialized for {repository.repo_type}")

    def version_exists(self, version: str) -> bool:
        """Check if version exists in repository."""
        return self.repository.exists(version)

    def get_version_artifacts(self, version: str) -> List[str]:
        """
        Get list of artifacts for a version.

        Returns:
            List of artifact paths relative to version directory
        """
        try:
            # Query index for artifact list
            index = self.repository.get_index()
            if not index:
                return []

            for release in index.get("releases", []):
                if release["version"] == version:
                    return release.get("artifacts", [])

            logger.warning(f"Version {version} not found in index")
            return []

        except Exception as e:
            logger.error(f"Failed to get artifacts for {version}: {e}")
            return []

    def backup_version(self, version: str) -> Tuple[bool, str]:
        """
        Create backup of version before rollback.

        Returns:
            (success, backup_path)
        """
        try:
            backup_id = str(uuid.uuid4())[:8]
            timestamp = datetime.now(timezone.utc).strftime("%Y%m%d_%H%M%S")
            backup_path = f"{self.backup_prefix}/{version}-{timestamp}-{backup_id}"

            logger.info(f"Creating backup: {version} → {backup_path}")

            # Get all artifacts for version
            artifacts = self.get_version_artifacts(version)

            if not artifacts:
                logger.warning(f"No artifacts found for {version}, creating minimal backup")
                # Still create backup directory with metadata
                backup_metadata = {
                    "version": version,
                    "backup_timestamp": datetime.now(timezone.utc).isoformat(),
                    "backup_id": backup_id,
                    "artifacts": [],
                }

                # Create backup metadata file
                temp_metadata = Path(f"/tmp/rollback-backup-{backup_id}.json")
                with open(temp_metadata, 'w') as f:
                    json.dump(backup_metadata, f, indent=2)

                self.repository.upload(temp_metadata, f"{backup_path}/metadata.json")
                temp_metadata.unlink()

                return True, backup_path

            # Backup each artifact
            backed_up = 0
            for artifact_path in artifacts:
                # artifact_path includes version prefix (e.g., "v1.0.2/file.txt")
                backup_artifact_path = f"{backup_path}/{artifact_path}"

                # Download artifact to temp location
                temp_file = Path(f"/tmp/rollback-backup-{uuid.uuid4()}.tmp")

                if self.repository.download(artifact_path, temp_file):
                    # Upload to backup location
                    if self.repository.upload(temp_file, backup_artifact_path):
                        backed_up += 1
                    temp_file.unlink()

            logger.info(f"Backup created: {backed_up}/{len(artifacts)} artifacts backed up")
            return backed_up > 0, backup_path

        except Exception as e:
            logger.error(f"Backup failed: {e}")
            return False, ""

    def rollback_version(self, version: str, artifacts: List[str]) -> Tuple[bool, int]:
        """
        Rollback (delete) version artifacts from repository.

        Args:
            version: Version to rollback
            artifacts: List of artifact paths to remove

        Returns:
            (success, artifacts_removed_count)
        """
        try:
            removed_count = 0
            failed_removals = []

            logger.info(f"Rolling back {len(artifacts)} artifacts for {version}")

            for artifact_path in artifacts:
                if self.repository.delete(artifact_path):
                    removed_count += 1
                else:
                    failed_removals.append(artifact_path)

            # Try to remove version directory
            try:
                self.repository.delete(version)
            except Exception as e:
                logger.warning(f"Could not remove version directory {version}: {e}")

            if failed_removals:
                logger.warning(f"Failed to remove {len(failed_removals)} artifacts: {failed_removals[:5]}")

            logger.info(f"Rollback complete: {removed_count}/{len(artifacts)} artifacts removed")
            return len(failed_removals) == 0, removed_count

        except Exception as e:
            logger.error(f"Rollback failed: {e}")
            return False, 0

    def restore_index(self, previous_index_data: Dict[str, Any]) -> bool:
        """
        Restore index to previous state.

        Args:
            previous_index_data: Previous index state

        Returns:
            success
        """
        try:
            logger.info("Restoring index to previous state")
            success = self.repository.update_index(previous_index_data)

            if success:
                logger.info("✓ Index restored successfully")
            else:
                logger.error("✗ Index restoration failed")

            return success

        except Exception as e:
            logger.error(f"Index restoration failed: {e}")
            return False

    def remove_from_index(self, version: str) -> Tuple[bool, Optional[Dict[str, Any]], Optional[Dict[str, Any]]]:
        """
        Remove version from index.

        Returns:
            (success, previous_index, updated_index)
        """
        try:
            current_index = self.repository.get_index()
            if not current_index:
                logger.error("Failed to retrieve current index")
                return False, None, None

            # Save previous state
            previous_index = current_index.copy()

            # Remove version from releases
            releases = current_index.get("releases", [])
            updated_releases = [r for r in releases if r["version"] != version]

            if len(updated_releases) == len(releases):
                logger.warning(f"Version {version} not found in index")
                return False, previous_index, None

            # Update index
            current_index["releases"] = updated_releases
            current_index["total_releases"] = len(updated_releases)
            current_index["last_updated"] = datetime.now(timezone.utc).isoformat()

            # Write updated index
            success = self.repository.update_index(current_index)

            if success:
                logger.info(f"✓ Removed {version} from index ({len(updated_releases)} releases remaining)")
                return True, previous_index, current_index
            else:
                logger.error("Failed to update index")
                return False, previous_index, None

        except Exception as e:
            logger.error(f"Failed to remove from index: {e}")
            return False, None, None

    def list_backups(self) -> List[str]:
        """List all backup versions."""
        try:
            versions = self.repository.list_versions()
            backups = [v for v in versions if v.startswith(self.backup_prefix)]
            logger.debug(f"Found {len(backups)} backups")
            return backups
        except Exception as e:
            logger.error(f"Failed to list backups: {e}")
            return []


# ============================================================================
# ROLLBACK POLICY ENGINE
# ============================================================================

class RollbackPolicyEngine:
    """
    Enforces rollback policies before executing rollback.
    Validates conditions that must be met for safe rollback.
    """

    def __init__(self, mode: RollbackPolicy = RollbackPolicy.STRICT):
        self.mode = mode
        logger.info(f"RollbackPolicyEngine initialized in {mode.value} mode")

    def enforce(
        self,
        version: str,
        repository_adapter: RollbackRepositoryAdapter,
        rollback_type: RollbackType = RollbackType.FULL,
        force: bool = False
    ) -> Tuple[bool, List[str], List[str]]:
        """
        Enforce rollback policy.

        Args:
            version: Version to rollback
            repository_adapter: Repository adapter
            rollback_type: Type of rollback
            force: Force rollback despite warnings

        Returns:
            (passed, warnings, errors)
        """
        warnings = []
        errors = []

        # Check 1: Version must exist
        if not repository_adapter.version_exists(version):
            msg = f"Version {version} not found in repository"
            if self.mode == RollbackPolicy.STRICT:
                errors.append(msg)
            else:
                warnings.append(msg)

        # Check 2: Version must have artifacts
        artifacts = repository_adapter.get_version_artifacts(version)
        if not artifacts:
            msg = f"No artifacts found for {version} (may already be rolled back)"
            if self.mode == RollbackPolicy.STRICT and not force:
                errors.append(msg)
            else:
                warnings.append(msg)

        # Check 3: Verify index consistency
        index = repository_adapter.repository.get_index()
        if index:
            versions_in_index = [r["version"] for r in index.get("releases", [])]
            if version not in versions_in_index:
                msg = f"Version {version} not in index (index may be inconsistent)"
                warnings.append(msg)

        # Check 4: Warn about rollback type implications
        if rollback_type == RollbackType.ARTIFACTS_ONLY:
            warnings.append("ARTIFACTS_ONLY rollback: Index entry will remain")
        elif rollback_type == RollbackType.INDEX_ONLY:
            warnings.append("INDEX_ONLY rollback: Artifacts will remain in repository")

        # Check 5: Warn if this is the latest version
        if index:
            releases = index.get("releases", [])
            if releases and releases[0]["version"] == version:
                warnings.append(f"{version} is the latest release - rollback may cause confusion")

        passed = len(errors) == 0
        return passed, warnings, errors


# ============================================================================
# ROLLBACK PLANNER
# ============================================================================

class RollbackPlanner:
    """
    Plans rollback execution.
    Validates dependencies and generates execution plan.
    """

    def __init__(self, repository_adapter: RollbackRepositoryAdapter):
        self.repository_adapter = repository_adapter

    def plan(
        self,
        version: str,
        rollback_type: RollbackType = RollbackType.FULL,
        dry_run: bool = False
    ) -> RollbackPlan:
        """
        Create rollback execution plan.

        Args:
            version: Version to rollback
            rollback_type: Type of rollback
            dry_run: Simulation mode

        Returns:
            RollbackPlan
        """
        logger.info(f"Planning {rollback_type.value} rollback for {version} (dry_run={dry_run})")

        plan = RollbackPlan(
            version=version,
            rollback_type=rollback_type,
            artifacts_to_remove=[],
            index_entry_to_remove=None,
            previous_index_state=None,
            dependencies_satisfied=True,
            estimated_duration_seconds=0.0,
            dry_run=dry_run
        )

        # Get artifacts to remove
        artifacts = self.repository_adapter.get_version_artifacts(version)
        if not artifacts:
            plan.warnings.append(f"No artifacts found for {version}")
            plan.dependencies_satisfied = False
        else:
            plan.artifacts_to_remove = artifacts
            # Estimate: ~50ms per artifact + 500ms overhead
            plan.estimated_duration_seconds = len(artifacts) * 0.05 + 0.5

        # Get index state
        index = self.repository_adapter.repository.get_index()
        if index:
            plan.previous_index_state = index.copy()

            # Find entry to remove
            for release in index.get("releases", []):
                if release["version"] == version:
                    plan.index_entry_to_remove = release
                    break

            if not plan.index_entry_to_remove:
                plan.warnings.append(f"Version {version} not found in index")

        # Validate dependencies
        if rollback_type == RollbackType.FULL:
            if not plan.artifacts_to_remove:
                plan.warnings.append("No artifacts to remove")
            if not plan.index_entry_to_remove:
                plan.warnings.append("No index entry to remove")

        logger.info(f"Plan created: {len(plan.artifacts_to_remove)} artifacts, "
                   f"estimated {plan.estimated_duration_seconds:.2f}s")

        return plan


# ============================================================================
# ROLLBACK EXECUTOR
# ============================================================================

class RollbackExecutor:
    """
    Executes rollback operations atomically.
    Implements atomic rollback with backup and recovery guarantees.
    """

    def __init__(self, repository_adapter: RollbackRepositoryAdapter):
        self.repository_adapter = repository_adapter
        self.rollback_id = str(uuid.uuid4())[:8]
        logger.info(f"RollbackExecutor initialized with ID: {self.rollback_id}")

    def execute(
        self,
        plan: RollbackPlan,
        create_backup: bool = True
    ) -> Tuple[bool, RollbackManifest, int]:
        """
        Execute rollback plan atomically.

        Args:
            plan: Rollback plan
            create_backup: Create backup before rollback

        Returns:
            (success, manifest, artifacts_removed_count)
        """
        if plan.dry_run:
            logger.info("DRY RUN: Simulating rollback execution")
            return self._dry_run_execute(plan)

        logger.info(f"Executing rollback for {plan.version} (type={plan.rollback_type.value})")

        manifest = RollbackManifest(
            version=plan.version,
            rollback_timestamp=datetime.now(timezone.utc).isoformat(),
            rollback_id=self.rollback_id,
            artifacts_removed=[],
            index_state_before=plan.previous_index_state or {},
            index_state_after={},
            rollback_type=plan.rollback_type.value,
        )

        backup_path = ""
        artifacts_removed = 0

        try:
            # Stage 1: Create backup
            if create_backup:
                logger.info("Stage 1: Creating backup")
                backup_success, backup_path = self.repository_adapter.backup_version(plan.version)

                if not backup_success:
                    raise RollbackBackupError(f"Failed to create backup for {plan.version}")

                logger.info(f"✓ Backup created: {backup_path}")
                manifest.can_restore = True
            else:
                logger.warning("Skipping backup creation (not recommended)")
                manifest.can_restore = False

            # Stage 2: Remove artifacts (if FULL or ARTIFACTS_ONLY)
            if plan.rollback_type in [RollbackType.FULL, RollbackType.ARTIFACTS_ONLY]:
                logger.info(f"Stage 2: Removing {len(plan.artifacts_to_remove)} artifacts")

                success, removed_count = self.repository_adapter.rollback_version(
                    plan.version,
                    plan.artifacts_to_remove
                )

                if not success:
                    raise RollbackAtomicError(f"Failed to remove all artifacts for {plan.version}")

                artifacts_removed = removed_count
                manifest.artifacts_removed = plan.artifacts_to_remove[:removed_count]
                logger.info(f"✓ Removed {removed_count} artifacts")

            # Stage 3: Update index (if FULL or INDEX_ONLY)
            if plan.rollback_type in [RollbackType.FULL, RollbackType.INDEX_ONLY]:
                logger.info("Stage 3: Updating index")

                success, prev_index, updated_index = self.repository_adapter.remove_from_index(plan.version)

                if not success:
                    raise RollbackIndexError(f"Failed to update index for {plan.version}")

                manifest.index_state_after = updated_index or {}
                logger.info("✓ Index updated")

            # Success
            logger.info(f"✓ Rollback complete: {plan.version} (ID: {self.rollback_id})")
            return True, manifest, artifacts_removed

        except Exception as e:
            logger.error(f"Rollback failed: {e}")

            # Attempt recovery if backup exists
            if backup_path and create_backup:
                logger.warning("Attempting recovery from backup (not implemented in this version)")
                # Recovery would involve restoring from backup_path

            raise RollbackAtomicError(f"Atomic rollback failed: {e}")

    def _dry_run_execute(self, plan: RollbackPlan) -> Tuple[bool, RollbackManifest, int]:
        """Execute dry-run simulation."""
        logger.info("=" * 60)
        logger.info("DRY RUN SIMULATION")
        logger.info("=" * 60)
        logger.info(f"Version: {plan.version}")
        logger.info(f"Rollback Type: {plan.rollback_type.value}")
        logger.info(f"Artifacts to remove: {len(plan.artifacts_to_remove)}")
        logger.info(f"Estimated duration: {plan.estimated_duration_seconds:.2f}s")

        if plan.warnings:
            logger.warning("Warnings:")
            for warning in plan.warnings:
                logger.warning(f"  - {warning}")

        logger.info("")
        logger.info("Operations that would be performed:")

        if plan.rollback_type in [RollbackType.FULL, RollbackType.ARTIFACTS_ONLY]:
            logger.info(f"  1. Backup version {plan.version}")
            logger.info(f"  2. Remove {len(plan.artifacts_to_remove)} artifacts:")
            for artifact in plan.artifacts_to_remove[:10]:  # Show first 10
                logger.info(f"     - {artifact}")
            if len(plan.artifacts_to_remove) > 10:
                logger.info(f"     ... and {len(plan.artifacts_to_remove) - 10} more")

        if plan.rollback_type in [RollbackType.FULL, RollbackType.INDEX_ONLY]:
            logger.info(f"  3. Remove {plan.version} from index")
            if plan.index_entry_to_remove:
                logger.info(f"     - Release timestamp: {plan.index_entry_to_remove.get('timestamp')}")
                logger.info(f"     - Artifacts: {len(plan.index_entry_to_remove.get('artifacts', []))}")

        logger.info("")
        logger.info("=" * 60)
        logger.info("DRY RUN COMPLETE - No changes made")
        logger.info("=" * 60)

        # Create simulation manifest
        manifest = RollbackManifest(
            version=plan.version,
            rollback_timestamp=datetime.now(timezone.utc).isoformat(),
            rollback_id=self.rollback_id,
            artifacts_removed=plan.artifacts_to_remove,
            index_state_before=plan.previous_index_state or {},
            index_state_after={},
            rollback_type=plan.rollback_type.value,
            rollback_reason="DRY RUN - Simulation only",
        )

        return True, manifest, len(plan.artifacts_to_remove)


# ============================================================================
# ROLLBACK ORCHESTRATOR
# ============================================================================

class RollbackOrchestrator:
    """
    Top-level orchestrator for release rollback.
    Coordinates policy enforcement, planning, execution, and audit logging.
    """

    def __init__(
        self,
        repository,
        policy_mode: RollbackPolicy = RollbackPolicy.STRICT,
        sign_audit_logs: bool = False
    ):
        """
        Initialize orchestrator.

        Args:
            repository: AbstractRepository instance (from publisher)
            policy_mode: Rollback policy mode
            sign_audit_logs: Sign audit logs
        """
        self.repository_adapter = RollbackRepositoryAdapter(repository)
        self.policy_engine = RollbackPolicyEngine(policy_mode)
        self.planner = RollbackPlanner(self.repository_adapter)

        self.policy_mode = policy_mode
        self.sign_audit_logs = sign_audit_logs

        logger.info(f"RollbackOrchestrator initialized (policy={policy_mode.value})")

    def rollback_release(
        self,
        version: str,
        rollback_type: RollbackType = RollbackType.FULL,
        dry_run: bool = False,
        force: bool = False,
        create_backup: bool = True,
        audit_output_dir: Optional[Path] = None,
        manifest_output_dir: Optional[Path] = None
    ) -> RollbackReport:
        """
        Execute complete rollback workflow.

        Args:
            version: Version to rollback
            rollback_type: Type of rollback (FULL, ARTIFACTS_ONLY, INDEX_ONLY)
            dry_run: Simulation mode (no actual changes)
            force: Force rollback despite warnings
            create_backup: Create backup before rollback
            audit_output_dir: Audit log output directory
            manifest_output_dir: Rollback manifest output directory

        Returns:
            RollbackReport with comprehensive details
        """
        start_time = datetime.now(timezone.utc)
        timestamp = start_time.isoformat()
        rollback_id = str(uuid.uuid4())[:8]

        report = RollbackReport(
            version=version,
            status=RollbackStatus.FAILED.value,
            timestamp=timestamp,
            rollback_type=rollback_type.value,
            rollback_id=rollback_id,
            repository_type=self.repository_adapter.repository.repo_type,
            repository_location=str(getattr(self.repository_adapter.repository, 'base_path', 'unknown')),
            policy_mode=self.policy_mode.value,
            dry_run=dry_run,
        )

        try:
            # Step 1: Policy enforcement
            logger.info(f"Step 1: Enforcing rollback policy for {version}")
            policy_passed, warnings, errors = self.policy_engine.enforce(
                version,
                self.repository_adapter,
                rollback_type,
                force
            )

            report.warnings.extend(warnings)
            report.errors.extend(errors)
            report.policy_passed = policy_passed
            report.version_exists = self.repository_adapter.version_exists(version)

            if not policy_passed and not force:
                report.exit_code = RollbackPolicyViolationError.exit_code
                report.summary = f"Rollback policy violations: {len(errors)} errors"
                raise RollbackPolicyViolationError(report.summary)

            if not policy_passed and force:
                logger.warning(f"Policy violations detected but proceeding due to force=True")
                report.warnings.append("Forced rollback despite policy violations")

            logger.info("✓ Policy checks passed")

            # Step 2: Create rollback plan
            logger.info("Step 2: Creating rollback execution plan")
            plan = self.planner.plan(version, rollback_type, dry_run)

            report.warnings.extend(plan.warnings)
            report.dependencies_satisfied = plan.dependencies_satisfied

            if not plan.dependencies_satisfied and not force:
                report.exit_code = RollbackDependencyError.exit_code
                report.summary = "Rollback dependencies not satisfied"
                raise RollbackDependencyError(report.summary)

            logger.info(f"✓ Plan created: {len(plan.artifacts_to_remove)} artifacts, "
                       f"~{plan.estimated_duration_seconds:.2f}s")

            # Step 3: Execute rollback
            logger.info(f"Step 3: Executing rollback (dry_run={dry_run})")
            executor = RollbackExecutor(self.repository_adapter)

            success, manifest, artifacts_removed = executor.execute(plan, create_backup)

            if not success:
                report.exit_code = RollbackAtomicError.exit_code
                report.summary = "Rollback execution failed"
                raise RollbackAtomicError(report.summary)

            report.artifacts_removed = manifest.artifacts_removed
            report.total_artifacts_removed = artifacts_removed
            report.backup_created = create_backup and manifest.can_restore
            report.index_updated = rollback_type in [RollbackType.FULL, RollbackType.INDEX_ONLY]

            logger.info(f"✓ Rollback executed: {artifacts_removed} artifacts removed")

            # Step 4: Calculate bytes freed (estimate)
            # In a real implementation, would sum actual file sizes
            report.total_bytes_freed = artifacts_removed * 50000  # Estimate 50KB per artifact

            # Step 5: Save rollback manifest
            if manifest_output_dir and not dry_run:
                logger.info("Step 4: Saving rollback manifest")
                manifest_saved = self._save_manifest(manifest, manifest_output_dir)
                report.manifest_created = manifest_saved

                if manifest_saved:
                    logger.info("✓ Rollback manifest saved")
            else:
                if dry_run:
                    logger.info("Skipping manifest save (dry run)")
                else:
                    logger.info("Manifest output directory not specified, skipping")

            # Step 6: Generate audit log
            if audit_output_dir and not dry_run:
                logger.info("Step 5: Generating audit log")
                audit_created, audit_signed = self._generate_audit_log(
                    version, manifest, report, audit_output_dir
                )
                report.audit_log_created = audit_created
                report.audit_log_signed = audit_signed

                if audit_created:
                    logger.info(f"✓ Audit log created (signed={audit_signed})")
            else:
                if dry_run:
                    logger.info("Skipping audit log (dry run)")
                else:
                    logger.info("Audit output directory not specified, skipping")

            # Success
            end_time = datetime.now(timezone.utc)
            report.rollback_duration_seconds = (end_time - start_time).total_seconds()

            if dry_run:
                report.status = RollbackStatus.DRY_RUN.value
                report.summary = f"DRY RUN: Would rollback {version} ({artifacts_removed} artifacts)"
            else:
                report.status = RollbackStatus.SUCCESS.value
                report.summary = f"Successfully rolled back {version} ({artifacts_removed} artifacts removed)"

            report.exit_code = 0

            logger.info(f"✓ Rollback complete: {version} ({report.rollback_duration_seconds:.2f}s)")
            return report

        except RollbackVersionNotFoundError as e:
            report.exit_code = e.exit_code
            report.errors.append(str(e))
            report.summary = str(e)
            logger.error(f"✗ Rollback failed: {e}")
            return report

        except RollbackPolicyViolationError as e:
            report.exit_code = e.exit_code
            report.summary = str(e)
            logger.error(f"✗ Rollback failed: {e}")
            return report

        except RollbackDependencyError as e:
            report.exit_code = e.exit_code
            report.errors.append(str(e))
            report.summary = str(e)
            logger.error(f"✗ Rollback failed: {e}")
            return report

        except RollbackAtomicError as e:
            report.exit_code = e.exit_code
            report.errors.append(str(e))
            report.summary = str(e)
            logger.error(f"✗ Rollback failed: {e}")
            return report

        except Exception as e:
            report.exit_code = RollbackError.exit_code
            report.errors.append(f"Unexpected error: {e}")
            report.summary = f"Rollback failed: {e}"
            logger.error(f"✗ Rollback failed: {e}", exc_info=True)
            return report

    def _save_manifest(self, manifest: RollbackManifest, output_dir: Path) -> bool:
        """Save rollback manifest to file."""
        try:
            output_dir.mkdir(parents=True, exist_ok=True)
            manifest_file = output_dir / f"{manifest.version}.rollback-manifest.json"

            with open(manifest_file, 'w', encoding='utf-8') as f:
                json.dump(asdict(manifest), f, indent=2, sort_keys=True)

            logger.info(f"Manifest saved: {manifest_file}")
            return True

        except Exception as e:
            logger.error(f"Failed to save manifest: {e}")
            return False

    def _generate_audit_log(
        self,
        version: str,
        manifest: RollbackManifest,
        report: RollbackReport,
        output_dir: Path
    ) -> Tuple[bool, bool]:
        """Generate rollback audit log."""
        try:
            audit_data = {
                "audit_id": str(uuid.uuid4()),
                "version": version,
                "timestamp": datetime.now(timezone.utc).isoformat(),
                "machine_id": platform.node(),
                "rollback_id": manifest.rollback_id,
                "rollback_type": manifest.rollback_type,
                "rollback_timestamp": manifest.rollback_timestamp,
                "manifest": asdict(manifest),
                "report": asdict(report),
            }

            # Write audit log
            output_dir.mkdir(parents=True, exist_ok=True)
            audit_file = output_dir / f"{version}.rollback-audit.json"

            with open(audit_file, 'w', encoding='utf-8') as f:
                json.dump(audit_data, f, indent=2, sort_keys=True)

            logger.info(f"Audit log created: {audit_file}")

            # Sign if requested
            if self.sign_audit_logs:
                sig_created = self._sign_audit_log(audit_file)
                return True, sig_created

            return True, False

        except Exception as e:
            logger.error(f"Failed to generate audit log: {e}")
            return False, False

    def _sign_audit_log(self, audit_file: Path) -> bool:
        """Sign audit log with RSA-PSS (simulated)."""
        try:
            # Read audit log
            with open(audit_file, 'rb') as f:
                audit_bytes = f.read()

            # Compute SHA256 hash
            audit_hash = hashlib.sha256(audit_bytes).hexdigest()

            # Create signature file (simulated)
            sig_file = audit_file.with_suffix('.rollback-audit.sig')
            sig_data = {
                "algorithm": "RSA-PSS-SHA256",
                "hash": audit_hash,
                "timestamp": datetime.now(timezone.utc).isoformat(),
                "note": "Simulated signature - replace with actual RSA-PSS in production"
            }

            with open(sig_file, 'w', encoding='utf-8') as f:
                json.dump(sig_data, f, indent=2)

            logger.info(f"Audit log signed: {sig_file}")
            return True

        except Exception as e:
            logger.error(f"Failed to sign audit log: {e}")
            return False

    def generate_json_report(self, report: RollbackReport, output_path: Path) -> bool:
        """Generate JSON rollback report."""
        try:
            output_path.parent.mkdir(parents=True, exist_ok=True)
            with open(output_path, 'w', encoding='utf-8') as f:
                json.dump(asdict(report), f, indent=2, sort_keys=True)
            logger.info(f"JSON report written: {output_path}")
            return True
        except Exception as e:
            logger.error(f"Failed to write JSON report: {e}")
            return False

    def generate_text_report(self, report: RollbackReport, output_path: Path) -> bool:
        """Generate text rollback report."""
        try:
            lines = [
                "=" * 80,
                "T.A.R.S. RELEASE ROLLBACK REPORT",
                "=" * 80,
                f"Version:              {report.version}",
                f"Status:               {report.status.upper()}",
                f"Rollback Type:        {report.rollback_type}",
                f"Rollback ID:          {report.rollback_id}",
                f"Timestamp:            {report.timestamp}",
                f"Repository Type:      {report.repository_type}",
                f"Repository Path:      {report.repository_location}",
                f"Policy Mode:          {report.policy_mode}",
                f"Dry Run:              {'YES' if report.dry_run else 'NO'}",
                f"Duration:             {report.rollback_duration_seconds:.2f}s",
                "",
                "-" * 80,
                "PRE-FLIGHT CHECKS",
                "-" * 80,
                f"Version Exists:          {'YES' if report.version_exists else 'NO'}",
                f"Policy Passed:           {'YES' if report.policy_passed else 'NO'}",
                f"Dependencies Satisfied:  {'YES' if report.dependencies_satisfied else 'NO'}",
                "",
                "-" * 80,
                "ROLLBACK DETAILS",
                "-" * 80,
                f"Artifacts Removed:       {report.total_artifacts_removed}",
                f"Total Bytes Freed:       {report.total_bytes_freed:,} bytes",
                f"Index Updated:           {'YES' if report.index_updated else 'NO'}",
                f"Backup Created:          {'YES' if report.backup_created else 'NO'}",
                f"Manifest Created:        {'YES' if report.manifest_created else 'NO'}",
                f"Audit Log Created:       {'YES' if report.audit_log_created else 'NO'}",
                f"Audit Log Signed:        {'YES' if report.audit_log_signed else 'NO'}",
                "",
            ]

            if report.artifacts_removed:
                lines.append("-" * 80)
                lines.append("REMOVED ARTIFACTS")
                lines.append("-" * 80)
                for artifact in report.artifacts_removed[:20]:  # First 20
                    lines.append(f"  - {artifact}")
                if len(report.artifacts_removed) > 20:
                    lines.append(f"  ... and {len(report.artifacts_removed) - 20} more")
                lines.append("")

            if report.warnings:
                lines.append("-" * 80)
                lines.append(f"WARNINGS ({len(report.warnings)})")
                lines.append("-" * 80)
                for warning in report.warnings:
                    lines.append(f"  ⚠ {warning}")
                lines.append("")

            if report.errors:
                lines.append("-" * 80)
                lines.append(f"ERRORS ({len(report.errors)})")
                lines.append("-" * 80)
                for error in report.errors:
                    lines.append(f"  ✗ {error}")
                lines.append("")

            lines.extend([
                "-" * 80,
                "SUMMARY",
                "-" * 80,
                report.summary,
                "",
                f"Exit Code: {report.exit_code}",
                "=" * 80,
            ])

            output_path.parent.mkdir(parents=True, exist_ok=True)
            with open(output_path, 'w', encoding='utf-8') as f:
                f.write("\n".join(lines))

            logger.info(f"Text report written: {output_path}")
            return True

        except Exception as e:
            logger.error(f"Failed to write text report: {e}")
            return False


# ============================================================================
# CLI INTERFACE
# ============================================================================

def main():
    """CLI entry point for release rollback."""
    import argparse
    import sys

    # Add parent directory to path to import publisher
    sys.path.insert(0, str(Path(__file__).parent.parent))
    from publisher.release_publisher import RepositoryFactory

    parser = argparse.ArgumentParser(description="T.A.R.S. Release Rollback System")
    parser.add_argument("--version", required=True, help="Release version to rollback")
    parser.add_argument("--repository-type", choices=["local", "s3", "gcs"], default="local")
    parser.add_argument("--repository-path", type=Path, help="Local repository path")
    parser.add_argument("--repository-bucket", help="S3/GCS bucket name")
    parser.add_argument("--repository-prefix", default="", help="S3/GCS prefix")
    parser.add_argument("--rollback-type", choices=["full", "artifacts_only", "index_only"],
                       default="full", help="Type of rollback")
    parser.add_argument("--policy", choices=["strict", "lenient"], default="strict")
    parser.add_argument("--dry-run", action="store_true", help="Simulate rollback without making changes")
    parser.add_argument("--force", action="store_true", help="Force rollback despite warnings")
    parser.add_argument("--no-backup", action="store_true", help="Skip backup creation (not recommended)")
    parser.add_argument("--sign-audit-log", action="store_true", default=False)
    parser.add_argument("--manifest-output-dir", type=Path, help="Rollback manifest output directory")
    parser.add_argument("--audit-output-dir", type=Path, help="Audit log output directory")
    parser.add_argument("--json-report", type=Path, help="JSON report output path")
    parser.add_argument("--text-report", type=Path, help="Text report output path")
    parser.add_argument("--verbose", action="store_true")

    args = parser.parse_args()

    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)

    # Build repository config
    repo_config = {"type": args.repository_type}
    if args.repository_type == "local":
        repo_config["path"] = args.repository_path or "./repository"
    else:
        repo_config["bucket"] = args.repository_bucket or "default-bucket"
        repo_config["prefix"] = args.repository_prefix

    # Create repository
    repository = RepositoryFactory.create(args.repository_type, repo_config)

    # Map rollback type
    rollback_type_map = {
        "full": RollbackType.FULL,
        "artifacts_only": RollbackType.ARTIFACTS_ONLY,
        "index_only": RollbackType.INDEX_ONLY,
    }
    rollback_type = rollback_type_map[args.rollback_type]

    # Create orchestrator
    policy_mode = RollbackPolicy.STRICT if args.policy == "strict" else RollbackPolicy.LENIENT
    orchestrator = RollbackOrchestrator(
        repository=repository,
        policy_mode=policy_mode,
        sign_audit_logs=args.sign_audit_log,
    )

    # Execute rollback
    report = orchestrator.rollback_release(
        version=args.version,
        rollback_type=rollback_type,
        dry_run=args.dry_run,
        force=args.force,
        create_backup=not args.no_backup,
        audit_output_dir=args.audit_output_dir,
        manifest_output_dir=args.manifest_output_dir,
    )

    # Generate reports
    if args.json_report:
        orchestrator.generate_json_report(report, args.json_report)

    if args.text_report:
        orchestrator.generate_text_report(report, args.text_report)

    # Print summary
    print(f"\n{'='*80}")
    print(f"Rollback Status: {report.status.upper()}")
    print(f"{'='*80}")
    print(report.summary)
    print(f"Exit Code: {report.exit_code}")
    print(f"{'='*80}\n")

    return report.exit_code


if __name__ == "__main__":
    exit(main())
