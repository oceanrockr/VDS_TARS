"""
Production-Grade SLSA Provenance Generator for T.A.R.S.

Generates SLSA (Supply-chain Levels for Software Artifacts) provenance metadata
compliant with in-toto attestation framework and SLSA v1.0 specification.

Features:
- Complete provenance generation for SLSA Level 2-3
- SHA-256 digest calculation for build artifacts
- Complete material tracking (dependencies, source files)
- Builder identity and metadata
- Build environment capture
- External parameters tracking
- Cryptographic signing support (RSA-PSS)
- Deterministic output

Targets:
- SLSA Level 2: Provenance generated by build service
- SLSA Level 3: Build hardened against tampering

Reference: https://slsa.dev/provenance/v1
"""

from typing import Dict, Any, List, Optional, Union
from pathlib import Path
from datetime import datetime, timezone
import json
import hashlib
import platform
import os
import sys
import subprocess
import logging
import uuid as uuid_module

# Configure logging
logger = logging.getLogger(__name__)


class SLSAProvenanceGenerator:
    """
    Production-grade SLSA provenance generator targeting Level 2-3.

    Generates provenance attestations following:
    - in-toto attestation framework
    - SLSA provenance v1.0 specification
    - Cryptographic signing for integrity
    """

    def __init__(
        self,
        project_name: str = "T.A.R.S.",
        project_version: str = "1.0.2",
        repository_url: str = "https://github.com/veleron-dev-studios/tars",
        builder_id: str = "https://github.com/veleron-dev-studios/tars/actions",
        vendor: str = "Veleron Dev Studios"
    ):
        """
        Initialize SLSA provenance generator.

        Args:
            project_name: Project name
            project_version: Project version
            repository_url: Source repository URL
            builder_id: Builder identity (CI/CD system URL)
            vendor: Vendor/organization name
        """
        self.project_name = project_name
        self.project_version = project_version
        self.repository_url = repository_url
        self.builder_id = builder_id
        self.vendor = vendor

    def generate_provenance(
        self,
        artifact_paths: Union[Path, List[Path]],
        build_type: str = "https://slsa.dev/build-types/python/wheel/v1",
        build_config_path: Optional[Path] = None,
        invocation_id: Optional[str] = None,
        started_on: Optional[datetime] = None,
        finished_on: Optional[datetime] = None,
        include_materials: bool = True
    ) -> Dict[str, Any]:
        """
        Generate SLSA provenance v1.0 attestation.

        Args:
            artifact_paths: Path(s) to build artifact(s)
            build_type: URI identifying the build type
            build_config_path: Path to build configuration file
            invocation_id: Unique build invocation ID (auto-generated if not provided)
            started_on: Build start timestamp
            finished_on: Build finish timestamp
            include_materials: Whether to include materials (dependencies)

        Returns:
            SLSA provenance attestation document
        """
        # Normalize artifact paths to list
        if isinstance(artifact_paths, Path):
            artifact_paths = [artifact_paths]

        logger.info(f"Generating SLSA provenance for {len(artifact_paths)} artifact(s)")

        # Calculate artifact digests
        subjects = []
        for artifact_path in artifact_paths:
            if not artifact_path.exists():
                logger.warning(f"Artifact not found: {artifact_path}")
                continue

            digest = self._calculate_sha256(artifact_path)
            subjects.append({
                "name": artifact_path.name,
                "digest": {
                    "sha256": digest
                }
            })

        if not subjects:
            raise ValueError("No valid artifacts found to generate provenance")

        # Generate invocation ID if not provided
        if not invocation_id:
            invocation_id = self._generate_invocation_id()

        # Timestamps
        if not started_on:
            started_on = datetime.now(timezone.utc)
        if not finished_on:
            finished_on = datetime.now(timezone.utc)

        # Build external parameters
        external_parameters = self._get_external_parameters(build_config_path)

        # Build internal parameters
        internal_parameters = self._get_internal_parameters()

        # Resolved dependencies (materials)
        resolved_dependencies = []
        if include_materials:
            resolved_dependencies = self._get_resolved_dependencies()

        # Build provenance document
        provenance = {
            "_type": "https://in-toto.io/Statement/v1",
            "subject": subjects,
            "predicateType": "https://slsa.dev/provenance/v1",
            "predicate": {
                "buildDefinition": {
                    "buildType": build_type,
                    "externalParameters": external_parameters,
                    "internalParameters": internal_parameters,
                    "resolvedDependencies": resolved_dependencies
                },
                "runDetails": {
                    "builder": {
                        "id": self.builder_id,
                        "version": {
                            "tars-build-system": self.project_version
                        }
                    },
                    "metadata": {
                        "invocationId": invocation_id,
                        "startedOn": started_on.isoformat(),
                        "finishedOn": finished_on.isoformat()
                    },
                    "byproducts": self._get_byproducts()
                }
            }
        }

        logger.info(f"Generated SLSA provenance with {len(subjects)} subject(s)")
        return provenance

    def _get_external_parameters(self, build_config_path: Optional[Path] = None) -> Dict[str, Any]:
        """
        Get external build parameters (user-controlled inputs).

        Args:
            build_config_path: Path to build configuration file

        Returns:
            External parameters dictionary
        """
        parameters = {
            "repository": self.repository_url,
            "ref": f"refs/tags/v{self.project_version}",
            "version": self.project_version,
            "project_name": self.project_name
        }

        # Add git commit information if available
        git_info = self._get_git_info()
        if git_info:
            parameters.update(git_info)

        # Add build configuration if provided
        if build_config_path and build_config_path.exists():
            parameters["buildConfig"] = {
                "path": str(build_config_path),
                "digest": {
                    "sha256": self._calculate_sha256(build_config_path)
                }
            }

        return parameters

    def _get_internal_parameters(self) -> Dict[str, Any]:
        """
        Get internal build parameters (controlled by builder).

        Returns:
            Internal parameters dictionary
        """
        parameters = {
            "platform": platform.system(),
            "architecture": platform.machine(),
            "python_version": platform.python_version(),
            "python_implementation": platform.python_implementation(),
            "os_release": platform.release(),
            "builder_vendor": self.vendor
        }

        # Add environment variables (filtered)
        env_vars = self._get_safe_env_vars()
        if env_vars:
            parameters["environment"] = env_vars

        return parameters

    def _get_resolved_dependencies(self) -> List[Dict[str, Any]]:
        """
        Get resolved dependencies (materials) for the build.

        Returns:
            List of dependency descriptors with digests
        """
        dependencies = []

        # Add requirements files
        req_files = [
            Path("requirements.txt"),
            Path("requirements-dev.txt"),
            Path("setup.py"),
            Path("pyproject.toml")
        ]

        for req_file in req_files:
            if req_file.exists():
                dependencies.append({
                    "uri": f"file:///{req_file}",
                    "digest": {
                        "sha256": self._calculate_sha256(req_file)
                    },
                    "name": req_file.name
                })

        # Add installed packages with versions
        installed_packages = self._get_installed_packages()
        for pkg_name, pkg_version in installed_packages.items():
            dependencies.append({
                "uri": f"pkg:pypi/{pkg_name}@{pkg_version}",
                "name": pkg_name,
                "annotations": {
                    "version": pkg_version,
                    "package_manager": "pip"
                }
            })

        logger.debug(f"Found {len(dependencies)} resolved dependencies")
        return dependencies

    def _get_installed_packages(self) -> Dict[str, str]:
        """
        Get installed Python packages with versions.

        Returns:
            Dictionary mapping package names to versions
        """
        try:
            result = subprocess.run(
                [sys.executable, "-m", "pip", "list", "--format=json"],
                capture_output=True,
                text=True,
                check=True,
                timeout=30
            )

            packages = json.loads(result.stdout)
            return {pkg['name']: pkg['version'] for pkg in packages}

        except (subprocess.SubprocessError, json.JSONDecodeError) as e:
            logger.warning(f"Failed to get installed packages: {e}")
            return {}

    def _get_byproducts(self) -> List[Dict[str, Any]]:
        """
        Get build byproducts (logs, reports, etc.).

        Returns:
            List of byproduct descriptors
        """
        byproducts = []

        # Add common build artifacts
        artifact_patterns = [
            "build.log",
            "test-results.xml",
            "coverage.xml",
            ".coverage"
        ]

        for pattern in artifact_patterns:
            path = Path(pattern)
            if path.exists():
                byproducts.append({
                    "uri": f"file:///{path}",
                    "digest": {
                        "sha256": self._calculate_sha256(path)
                    },
                    "name": path.name
                })

        return byproducts

    def _get_git_info(self) -> Optional[Dict[str, str]]:
        """
        Get Git repository information.

        Returns:
            Git metadata or None if not a git repository
        """
        try:
            # Check if git is available
            subprocess.run(
                ["git", "--version"],
                capture_output=True,
                check=True,
                timeout=5
            )

            # Get commit hash
            commit_result = subprocess.run(
                ["git", "rev-parse", "HEAD"],
                capture_output=True,
                text=True,
                check=True,
                timeout=5
            )
            commit_sha = commit_result.stdout.strip()

            # Get branch name
            branch_result = subprocess.run(
                ["git", "rev-parse", "--abbrev-ref", "HEAD"],
                capture_output=True,
                text=True,
                check=True,
                timeout=5
            )
            branch = branch_result.stdout.strip()

            # Get remote URL
            remote_result = subprocess.run(
                ["git", "config", "--get", "remote.origin.url"],
                capture_output=True,
                text=True,
                check=True,
                timeout=5
            )
            remote_url = remote_result.stdout.strip()

            return {
                "commit_sha": commit_sha,
                "branch": branch,
                "remote_url": remote_url
            }

        except (subprocess.SubprocessError, FileNotFoundError):
            logger.debug("Git information not available")
            return None

    def _get_safe_env_vars(self) -> Dict[str, str]:
        """
        Get safe environment variables (excluding secrets).

        Returns:
            Dictionary of safe environment variables
        """
        # Allowed environment variable prefixes
        allowed_prefixes = [
            "PYTHON",
            "PATH",
            "HOME",
            "USER",
            "CI",
            "GITHUB",
            "TARS"
        ]

        # Blocked environment variable names (potential secrets)
        blocked_names = [
            "TOKEN",
            "SECRET",
            "PASSWORD",
            "KEY",
            "API_KEY",
            "PRIVATE"
        ]

        safe_vars = {}
        for key, value in os.environ.items():
            # Check if allowed prefix
            if not any(key.startswith(prefix) for prefix in allowed_prefixes):
                continue

            # Check if blocked name
            if any(blocked in key.upper() for blocked in blocked_names):
                continue

            # Add to safe vars
            safe_vars[key] = value

        return safe_vars

    def save_provenance(
        self,
        provenance: Dict[str, Any],
        output_path: Path,
        sign: bool = False,
        signing_key_path: Optional[Path] = None
    ) -> None:
        """
        Save provenance to file with optional cryptographic signing.

        Args:
            provenance: SLSA provenance document
            output_path: Path to save provenance file
            sign: Whether to sign the provenance
            signing_key_path: Path to RSA private key for signing
        """
        # Create output directory
        output_path.parent.mkdir(parents=True, exist_ok=True)

        # Write provenance
        with open(output_path, 'w', encoding='utf-8') as f:
            json.dump(provenance, f, indent=2, sort_keys=True)

        logger.info(f"Generated SLSA provenance: {output_path}")

        # Sign if requested
        if sign:
            if not signing_key_path or not signing_key_path.exists():
                raise ValueError("Signing key path must be provided and exist")

            self._sign_provenance(output_path, signing_key_path)

    def _sign_provenance(self, provenance_path: Path, signing_key_path: Path) -> None:
        """
        Sign provenance using RSA-PSS signature.

        Args:
            provenance_path: Path to provenance file
            signing_key_path: Path to RSA private key
        """
        try:
            from cryptography.hazmat.primitives import hashes, serialization
            from cryptography.hazmat.primitives.asymmetric import padding
            from cryptography.hazmat.backends import default_backend
        except ImportError:
            logger.error("cryptography library not installed, cannot sign provenance")
            return

        # Read provenance
        with open(provenance_path, 'rb') as f:
            provenance_data = f.read()

        # Load private key
        with open(signing_key_path, 'rb') as f:
            private_key = serialization.load_pem_private_key(
                f.read(),
                password=None,
                backend=default_backend()
            )

        # Sign
        signature = private_key.sign(
            provenance_data,
            padding.PSS(
                mgf=padding.MGF1(hashes.SHA256()),
                salt_length=padding.PSS.MAX_LENGTH
            ),
            hashes.SHA256()
        )

        # Save signature
        sig_path = provenance_path.with_suffix(provenance_path.suffix + '.sig')
        with open(sig_path, 'wb') as f:
            f.write(signature)

        logger.info(f"Generated signature: {sig_path}")

    def _calculate_sha256(self, file_path: Path) -> str:
        """
        Calculate SHA-256 hash of file.

        Args:
            file_path: Path to file

        Returns:
            SHA-256 hash (hex string)
        """
        sha256 = hashlib.sha256()

        with open(file_path, 'rb') as f:
            for chunk in iter(lambda: f.read(8192), b""):
                sha256.update(chunk)

        return sha256.hexdigest()

    def _generate_invocation_id(self) -> str:
        """
        Generate unique invocation ID for this build.

        Returns:
            Unique invocation ID (UUID)
        """
        # Use UUIDv4 for randomness
        return str(uuid_module.uuid4())

    def verify_provenance(
        self,
        provenance_path: Path,
        public_key_path: Path
    ) -> bool:
        """
        Verify provenance signature.

        Args:
            provenance_path: Path to provenance file
            public_key_path: Path to RSA public key

        Returns:
            True if signature is valid, False otherwise
        """
        try:
            from cryptography.hazmat.primitives import hashes, serialization
            from cryptography.hazmat.primitives.asymmetric import padding
            from cryptography.hazmat.backends import default_backend
        except ImportError:
            logger.error("cryptography library not installed, cannot verify signature")
            return False

        # Check if signature file exists
        sig_path = provenance_path.with_suffix(provenance_path.suffix + '.sig')
        if not sig_path.exists():
            logger.error(f"Signature file not found: {sig_path}")
            return False

        # Read provenance and signature
        with open(provenance_path, 'rb') as f:
            provenance_data = f.read()

        with open(sig_path, 'rb') as f:
            signature = f.read()

        # Load public key
        with open(public_key_path, 'rb') as f:
            public_key = serialization.load_pem_public_key(
                f.read(),
                backend=default_backend()
            )

        # Verify signature
        try:
            public_key.verify(
                signature,
                provenance_data,
                padding.PSS(
                    mgf=padding.MGF1(hashes.SHA256()),
                    salt_length=padding.PSS.MAX_LENGTH
                ),
                hashes.SHA256()
            )
            logger.info("Provenance signature verified successfully")
            return True

        except Exception as e:
            logger.error(f"Signature verification failed: {e}")
            return False


def generate_slsa_provenance_for_tars(
    artifact_paths: Union[Path, List[Path]],
    output_path: Path,
    build_type: str = "https://slsa.dev/build-types/python/wheel/v1",
    sign: bool = False,
    signing_key_path: Optional[Path] = None,
    project_version: Optional[str] = None
) -> None:
    """
    Generate SLSA provenance for T.A.R.S. artifacts.

    Args:
        artifact_paths: Path(s) to build artifact(s)
        output_path: Path to save provenance file
        build_type: Build type URI
        sign: Whether to sign provenance
        signing_key_path: Path to RSA signing key
        project_version: Project version (reads from VERSION file if not provided)
    """
    # Read version from VERSION file if not provided
    if not project_version:
        version_file = Path(__file__).parent.parent / "VERSION"
        if version_file.exists():
            project_version = version_file.read_text().strip()
        else:
            project_version = "1.0.2"

    logger.info(f"Generating SLSA provenance for T.A.R.S. v{project_version}")

    generator = SLSAProvenanceGenerator(
        project_name="T.A.R.S.",
        project_version=project_version,
        repository_url="https://github.com/veleron-dev-studios/tars",
        builder_id="https://github.com/veleron-dev-studios/tars/actions",
        vendor="Veleron Dev Studios"
    )

    # Generate provenance
    provenance = generator.generate_provenance(
        artifact_paths=artifact_paths,
        build_type=build_type,
        include_materials=True
    )

    # Save provenance
    generator.save_provenance(
        provenance=provenance,
        output_path=output_path,
        sign=sign,
        signing_key_path=signing_key_path
    )

    logger.info("SLSA provenance generation complete")


if __name__ == "__main__":
    # CLI interface
    import argparse

    parser = argparse.ArgumentParser(description="Generate SLSA provenance for T.A.R.S.")
    parser.add_argument(
        "artifacts",
        nargs="+",
        type=Path,
        help="Path(s) to build artifact(s)"
    )
    parser.add_argument(
        "--output",
        type=Path,
        required=True,
        help="Output path for provenance file"
    )
    parser.add_argument(
        "--build-type",
        default="https://slsa.dev/build-types/python/wheel/v1",
        help="Build type URI"
    )
    parser.add_argument(
        "--sign",
        action="store_true",
        help="Sign provenance with RSA key"
    )
    parser.add_argument(
        "--signing-key",
        type=Path,
        help="Path to RSA private key for signing"
    )
    parser.add_argument(
        "--version",
        help="Project version (default: read from VERSION file)"
    )
    parser.add_argument(
        "--verbose",
        action="store_true",
        help="Enable verbose logging"
    )
    parser.add_argument(
        "--verify",
        action="store_true",
        help="Verify existing provenance signature"
    )
    parser.add_argument(
        "--public-key",
        type=Path,
        help="Path to RSA public key for verification"
    )

    args = parser.parse_args()

    # Configure logging
    logging.basicConfig(
        level=logging.DEBUG if args.verbose else logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )

    # Verify mode
    if args.verify:
        if not args.public_key or not args.public_key.exists():
            parser.error("--public-key required for verification")

        generator = SLSAProvenanceGenerator()
        is_valid = generator.verify_provenance(args.output, args.public_key)
        sys.exit(0 if is_valid else 1)

    # Generate mode
    generate_slsa_provenance_for_tars(
        artifact_paths=args.artifacts,
        output_path=args.output,
        build_type=args.build_type,
        sign=args.sign,
        signing_key_path=args.signing_key,
        project_version=args.version
    )
